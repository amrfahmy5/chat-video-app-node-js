"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Http = require("http");
const Youch = require("youch");
/**
 * WARNING: public API. If this interface changes, then it is a BREAKING change (bump module major version).
 */
class NormalizedException {
    constructor(statusCode, name, message, stack) {
        this.statusCode = statusCode;
        this.name = name;
        this.message = message;
        this.stack = stack;
    }
    get status() {
        return this.statusCode;
    }
    toString() {
        return formatTextResponse(this);
    }
}
exports.NormalizedException = NormalizedException;
const defaultErrorReporterOptions = {
    links: []
};
/**
 * An express-compatible middleware to catch all errors.
 *
 * Use like this:
 *
   ```ts
   import { errorReporter } from 'express-youch';

   app.use(errorReporter());
   ```
 */
function errorReporter(options) {
    const realOptions = Object.assign(Object.assign({}, defaultErrorReporterOptions), options);
    return (err, req, res, next) => {
        if (res.headersSent) {
            return next(err);
        }
        const normalized = createErrorDescriptor(err);
        sendException(req, res, stripProductionAttributes(normalized), realOptions).then(() => next(normalized));
    };
}
exports.errorReporter = errorReporter;
function stripProductionAttributes(exception) {
    return new NormalizedException(exception.status, exception.name, exception.message, isRunningInProd() ? '' : exception.stack);
}
/**
 * Converts an unknown error type into a precise description of the error that
 * we can easily report.
 */
function createErrorDescriptor(err) {
    const maybeMessage = 'message' in err ? err.message : safeToString(err);
    const status = extractStatusCode(err);
    return new NormalizedException(status, 'constructor' in err ? err.constructor.name : 'name' in err && err.name != null ? err.name : 'Unknown error', maybeMessage ? maybeMessage : Http.STATUS_CODES[status] || '', 'stack' in err ? err.stack : undefined);
}
/**
 * Reports the description of an error back to the user while respecting the 'Accept' header if possible.
 */
function sendException(req, res, err, options) {
    return __awaiter(this, void 0, void 0, function* () {
        switch (getPreferredResponseFormat(req)) {
            case 'json':
                res.status(err.status).json(err);
                break;
            case 'text':
                res.status(err.status).contentType('text/plain').send(formatTextResponse(err));
                break;
            case 'html':
                if (!isRunningInProd()) {
                    return sendYouchError(req, res, err, options);
                }
                // If the app is running in prod, we let the next middleware down the stack decide how
                // to print the error.
                // This will usually allow a user to provide their own nice customized error pages.
                break;
        }
    });
}
/**
 * Figures out what response format is the most appropriate given some request.
 */
function getPreferredResponseFormat(req) {
    const acceptHeader = req.header('Accept');
    if (acceptHeader != null) {
        if (acceptHeader.indexOf('application/json') !== -1) {
            return 'json';
        }
        else if (acceptHeader.indexOf('text/html') !== -1) {
            return 'html';
        }
    }
    return 'text';
}
function sendYouchError(req, res, err, options) {
    const youch = options
        .links
        .reduce((youchBuilder, link) => youchBuilder.addLink(link), new Youch(err, req));
    return youch.toHTML().then((html) => {
        res.writeHead(err.status, { 'content-type': 'text/html' });
        res.write(html);
        res.end();
    });
}
function formatTextResponse(err) {
    return err.name + ': ' + (err.message ? err.message : 'Unknown error') + '\n' + (err.stack ? err.stack : '');
}
function extractStatusCode(err) {
    let status;
    if ('statusCode' in err && (status = validateStatusCode(err.statusCode))) {
        return status;
    }
    if ('status' in err && (status = validateStatusCode(err.status))) {
        return status;
    }
    if ('code' in err && (status = validateStatusCode(err.code))) {
        return status;
    }
    return 500;
}
function validateStatusCode(code) {
    if (code == null) {
        return;
    }
    const status = safeToNumber(code);
    // Loose sanity check to avoid capturing stuff that's not an HTTP status code
    if (status != null && status >= 400 && status < 600) {
        return status;
    }
}
function safeToNumber(status) {
    if (typeof status === 'number') {
        return status;
    }
    try {
        return parseInt(status, 10);
    }
    catch (e) {
        return undefined;
    }
}
function safeToString(err) {
    try {
        return err.toString();
    }
    catch (e) {
        return '';
    }
}
function isRunningInProd() {
    return process.env.NODE_ENV === 'production';
}
